<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>headtohead</title>

  <!-- ✅ 外部CSSを読み込む -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <div class="qwrap">
    <p class="round-label" id="round-label">Round: —</p>
    <p class="view-label"  id="view-label">Views: 0</p>
    <p class="question" aria-live="polite">
      <button class="name-btn" id="btn-left" title="左に投票">
        <strong id="label-left">—</strong>
      </button>
      か
      <button class="name-btn" id="btn-right" title="右に投票">
        <strong id="label-right">—</strong>
      </button>
    </p>
  </div>

<script type="module">
/* ===== Firebase v12.4.0（変更不可） ===== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc,
  runTransaction, onSnapshot, serverTimestamp
} from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

/* ===== Firebase 設定 ===== */
const firebaseConfig = {
  apiKey: "AIzaSyCRHvaE9WMODFhDau9sgqs11lzkW6wrFbc",
  authDomain: "project-617841149941118768.firebaseapp.com",
  projectId: "project-617841149941118768",
  storageBucket: "project-617841149941118768.firebasestorage.app",
  messagingSenderId: "699664731293",
  appId: "1:699664731293:web:0ab38c64fb6fc023049874"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ===== 1024候補の配列 =====
const OPTIONS = [
"りんご","オレンジ","ぶどう","もも","スイカ","バナナ","パイナップル","いちご","マンゴー","メロン","キウイ",
"さくらんぼ","レモン","ライム","ブルーベリー","ラズベリー","ブラックベリー","プラム","あんず","ココナッツ","パパイヤ",
"いちじく","デーツ","グアバ","ライチ","パッションフルーツ","ザクロ","クランベリー","みかん","かき","マルベリー",
"トマト","アボカド","オリーブ","きゅうり","かぼちゃ","にんじん","じゃがいも","たまねぎ","にんにく","ブロッコリー",
"カリフラワー","ほうれんそう","レタス","キャベツ","セロリ","えんどう","まめ","とうもろこし","こめ","むぎ",
"オート麦","大麦","ライ麦","きび","もろこし","キヌア","アマランサス","そば","アーモンド","くるみ",
"ピーカンナッツ","ヘーゼルナッツ","カシューナッツ","ピスタチオ","マカダミアナッツ","くり","ピーナッツ","ひまわり","ごま","あまに",
"チア","ココナッツウォーター","はちみつ","砂糖","塩","こしょう","酢","油","バター","チーズ",
"牛乳","クリーム","ヨーグルト","卵","パン","ケーキ","パイ","クッキー","チョコレート","キャンディ",
"コーヒー","お茶","ジュース","水","ソーダ","ビール","ワイン","ウイスキー","ラム","ウォッカ",
"ジン","ブランデー","シャンパン","シードル","スムージー","スープ","シチュー","サラダ","パスタ","ピザ",
"バーガー","サンドイッチ","すし","カレー","ステーキ","チキン","ビーフ","ポーク","魚","えび",
"かに","ロブスター","たこ","いか","豆腐","めん","ぎょうざ","おにぎり","弁当","てんぷら",
"ラーメン","うどん","そば","シリアル","おかゆ","オムレツ","トースト","ジャム","バタートースト","チーズトースト",
"ポップコーン","ナチョス","タコス","ブリトー","ケサディーヤ","ホットドッグ","フライドポテト","ケチャップ","マスタード","マヨネーズ",
"カップラーメン","インスタント麺","もち","プリン","アイスクリーム","ジェラート","ソルベ","ドーナツ","パンケーキ","ワッフル",
"マフィン","クロワッサン","ベーグル","プレッツェル","ビスケット","グラノーラ","トレイルミックス","ソーセージ","ハム","ベーコン",
"サラミ","プロシュート","キャビア","さしみ","天ぷらえび","焼き魚","てりやき","やきとり","そばめん","すきやき",
"しゃぶしゃぶ","なべ","キムチ","ビビンバ","トッポギ","キンパ","フォー","春巻き","水餃子","チャーハン",
"キャセロール","リゾット","パエリア","ラザニア","スパゲッティ","カルボナーラ","ボロネーゼ","ティラミス","ゼリー","カスタード",
"トリュフ","魚卵","わさび","しょうゆ","みそ","海藻","のり","ごま油","日本酒","焼酎",
"抹茶","緑茶","ウーロン茶","紅茶","ハーブティー","ラテ","カプチーノ","エスプレッソ","アメリカーノ","マキアート",
"モカ","アイスコーヒー","レモネード","コーラ","ジンジャーエール","エナジードリンク","ベリースムージー","プロテインシェイク","ココナッツミルク","アーモンドミルク",
"豆乳","オートミルク","炭酸水","ミネラルウォーター","水道水","雨","雪","氷","風","雲",
"雷","稲妻","嵐","虹","太陽","月","星","惑星","彗星","流星",
"銀河","宇宙","原子","分子","元素","化合物","結晶","宝石","ダイヤモンド","ルビー",
"サファイア","エメラルド","トパーズ","アメジスト","オパール","パール","サンゴ","水晶","花崗岩","大理石",
"砂","土","岩","山","谷","川","湖","海","浜辺","島",
"砂漠","森","ジャングル","沼","草原","平原","ツンドラ","氷河","渓谷","崖",
"火山","洞窟","滝","泉","間欠泉","波","潮","流れ","サンゴ礁","クジラ",
"イルカ","サメ","アザラシ","ペンギン","ホッキョクグマ","トラ","ライオン","ヒョウ","チーター","ゾウ",
"キリン","シマウマ","サイ","カバ","シカ","ウサギ","キツネ","オオカミ","クマ","イヌ",
"ネコ","ウマ","ウシ","ブタ","ヒツジ","ヤギ","ニワトリ","アヒル","ガチョウ","ワシ",
"タカ","フクロウ","オウム","クジャク","カラス","スズメ","ハト","ハクチョウ","フラミンゴ","チョウ",
"ハチ","アリ","クモ","コオロギ","バッタ","トンボ","ホタル","カブトムシ","てんとう虫","ヘビ",
"トカゲ","カエル","カメ","ワニ","アリゲーター","ジンベイザメ","イルカの子","タコのインク","クラゲ","ヒトデ",
"ハマグリ","カタツムリ","ミミズ","キノコ","サンゴ魚","木","花","葉","根","種",
"つぼみ","果実","枝","樹皮","茎","花びら","つる","アイビー","コケ","シダ",
"竹","サボテン","バラ","チューリップ","ユリ","ひまわり","デイジー","ラン","ラベンダー","桜",
"もみじ","オーク","松","杉","柳","白樺","ヤシ","バナナの木","りんごの木","みかんの木",
"ぶどうの木","稲","小麦","とうもろこしの木","大麦の穂","トマトの木","かぼちゃのつる","メロンのつる","キウイのつる","コンピューター",
"ノートパソコン","タブレット","スマートフォン","モニター","キーボード","マウス","プリンター","カメラ","スピーカー","マイク",
"ヘッドフォン","テレビ","ラジオ","時計","腕時計","電卓","ドローン","ロボット","車","バス",
"電車","飛行機","ヘリコプター","船","ボート","潜水艦","自転車","バイク","スクーター","トラック",
"トラクター","ロケット","人工衛星","宇宙船","宇宙服","宇宙飛行士","地球","火星","金星","水星",
"木星","土星","天王星","海王星","冥王星","日光","星の光","月光","虹の光","火",
"水","空気","土","金属","木材","石","光","闇","影","エネルギー",
"力","魔法","精神","魂","心","夢","希望","愛","平和","喜び",
"真実","知恵","勇気","名誉","正義","自由","強さ","美しさ","調和","均衡",
"運命","宿命","幸運","勝利","敗北","栄光","誇り","王冠","玉座","王",
"女王","王子","王女","騎士","魔法使い","魔女","ドラゴン","妖精","エルフ","ドワーフ",
"ゴブリン","オーク","トロール","巨人","幽霊","吸血鬼","人狼","ゾンビ","天使","悪魔",
"モンスター","獣","勇者","悪役","戦士","弓使い","盗賊","暗殺者","僧侶","吟遊詩人",
"魔導士","錬金術師","技師","科学者","医者","看護師","教師","学生","芸術家","画家",
"音楽家","歌手","ダンサー","作家","詩人","俳優","監督","写真家","デザイナー","建築家",
"料理人","パン職人","農家","漁師","狩人","鉱夫","大工","仕立て屋","鍛冶屋","商人",
"銀行員","警備員","兵士","警察官","消防士","パイロット","船員","探検家","冒険者","発明家",
"学者","哲学者","指導者","大統領","王国","帝国","共和国","都市","村","町",
"城","宮殿","寺","教会","神社","橋","塔","門","壁","道",
"通り","公園","庭","広場","市場","港","駅","図書館","博物館","学校",
"大学","病院","劇場","映画館","アリーナ","スタジアム","ホテル","レストラン","カフェ","パン屋",
"バー","店","モール","家","アパート","建物","部屋","ドア","窓","屋根",
"床","壁","天井","ランプ","椅子","テーブル","机","ソファ","ベッド","鏡",
"カーテン","カーペット","テレビ","冷蔵庫","電子レンジ","オーブン","トースター","洗濯機","掃除機","扇風機",
"暖房","エアコン","本","ノート","ペン","鉛筆","消しゴム","定規","はさみ","のり",
"テープ","紙","カード","封筒","切手","地図","地球儀","カレンダー","日記","手紙",
"箱","かばん","ボトル","コップ","皿","どんぶり","フォーク","ナイフ","スプーン","はし",
"トレイ","ナプキン","タオル","毛布","まくら","シーツ","マットレス","クッション","おもちゃ","ゲーム",
"トランプ","ボードゲーム","テレビゲーム","コントローラー","さいころ","パズル","ボール","バット","ラケット","ネット",
"ゴール","ヘルメット","グローブ","靴","ブーツ","帽子","コート","ジャケット","シャツ","Tシャツ",
"ズボン","スカート","ドレス","スーツ","ネクタイ","ベルト","靴下","マフラー","めがね","腕時計",
"指輪","ネックレス","イヤリング","ブレスレット","財布","リュック","かばん","傘","鍵","ロック",
"ドアベル","郵便受け","レンズ","三脚","マイクロチップ","電池","ケーブル","プラグ","スイッチ","電球",
"ボタン","画面","センサー","チップ","サーバー","ネットワーク","クラウド","コード","プログラム","アルゴリズム",
"データ","データベース","API","ウェブサイト","ドメイン","ブラウザ","メール","メッセージ","チャット","通話",
"ビデオ","写真","音楽","音","声","言葉","文字","数字","方程式","式",
"グラフ","チャート","図","形","線","円","四角","三角","星形","ハート形",
"矢印","点","ベクトル","ピクセル","フレーム","アニメーション","動き","3Dモデル","レンダー","テクスチャ",
"色","赤","青","緑","黄","紫","ピンク","オレンジ色","茶色","灰色",
"黒","白","銀","金","銅","鉄","鋼","プラスチック","ガラス","紙",
"木","石","布","革","綿","ウール","シルク","麻","粘土","砂岩",
"コンクリート","レンガ","タイル","大理石材","花崗岩石","氷","蒸気","煙","ほこり","霧",
"雨粒","雪片","雷光","風音","嵐風","竜巻","波動","潮流","地震","火山灰",
"炎","火花","光線","放射","熱","冷気","圧力","真空","重力","磁石",
"電気","電流","電圧","回路","光波","音波","振動","周波数","信号","パターン",
"対称","混沌","秩序","構造","形態","概念","思考","知識","学び","科学",
"技術","芸術","文化","歴史","宗教","哲学","数学","物理","化学","生物",
"地理","天文学","文学","詩","音楽芸術","舞踊","絵画","彫刻","建築芸術","デザイン",
"演劇","映画","写真芸術","ファッション","料理","工芸","ゲームデザイン","アニメーション","プログラミング","人工知能",
"ロボットアーム","ニューラルネット","機械学習","量子","宇宙空間","時間","次元","エネルギー場","粒子","波動関数",
"宇宙の核","銀河団","ブラックホール","ワームホール","超新星","星雲","小惑星","隕石","彗星の尾","コスモス",
"無限","永遠","瞬間","未来","過去","現在","記憶","夢世界","想像","現実"
];

/* ===== パラメータ ===== */
const TOURNAMENT_DOC_ID = "main";
const VOTE_THRESHOLD    = 1;

/* ===== このクライアントのID（リセットの排他制御に使用） ===== */
const CLIENT_ID = (crypto.randomUUID?.() ?? String(Math.random()).slice(2));

/* ===== 表示補正（Round表示は内部+2、最大10） ===== */
const DISPLAY_OFFSET = 2;
const calcDisplayedRound = (internalRound) =>
  Math.min((internalRound ?? 1) + DISPLAY_OFFSET, 10);

/* ===== ユーティリティ ===== */
function shuffle(arr){
  const a = arr.slice();
  for (let i=a.length-1; i>0; i--){
    const j = crypto.getRandomValues(new Uint32Array(1))[0] % (i+1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function buildMatches(participants){
  const p = shuffle(participants);
  const m = [];
  let id = 1;
  for (let i=0; i<p.length; i+=2){
    m.push({ id:id++, left:p[i] ?? null, right:p[i+1] ?? null, winner:null, leftCount:0, rightCount:0 });
  }
  return m;
}
function allResolved(matches){ return matches.every(x => x.winner !== null); }
/* ✅ 追加：最初の“プレイ可能”試合を指すインデックス */
function firstPlayableIndex(matches){
  let i = 0;
  while (i < matches.length) {
    const m = matches[i];
    if (m.left && m.right && !m.winner) break;
    i++;
  }
  return i;
}

/* ===== 初期化（毎回1024→128候補ランダム抽出） ===== */
async function initTournamentIfNeeded(){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  const snap = await getDoc(ref);
  if (snap.exists()) return;

  const allShuffled = shuffle(OPTIONS);
  const selected128 = allShuffled.slice(0, 128);

  const matches = buildMatches(selected128);
  const nextCandidates = [];
  for (const m of matches){
    if (m.left && !m.right){ m.winner = m.left; nextCandidates.push(m.left); }
    else if (!m.left && m.right){ m.winner = m.right; nextCandidates.push(m.right); }
  }

  /* ✅ 不戦勝を反映した上で最初のプレイ可能試合へ */
  const matchIndex = firstPlayableIndex(matches);

  await setDoc(ref, {
    round: 1,
    matchIndex,
    matches,
    nextCandidates,
    champion: null,
    threshold: VOTE_THRESHOLD,
    updatedAt: serverTimestamp(),
    totalCandidates: 128,
    views: 0,
    /* ✅ 新規フィールド：チャンピオン後のリセット排他制御 */
    resetLock: null,
    championAt: null
  });
}

/* ===== ラウンド遷移 ===== */
/* ✅ 置き換え：トランザクションで単発実行＆playableIndex を設定（championAt/resetLockも管理） */
async function startNextRound(){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(ref);
    if (!snap.exists()) return;
    const d = snap.data();
    if (d.champion) return;

    const winners = (d.nextCandidates ?? []).slice();
    if (winners.length === 0) return;

    // まだ現ラウンドに未決着があれば遷移しない（二重トリガー防止）
    const matches = d.matches ?? [];
    if (!allResolved(matches)) return;

    if (winners.length === 1){
      // ✅ チャンピオン確定：championAt を付与し、resetLock をクリア
      tx.update(ref, {
        champion: winners[0],
        championAt: serverTimestamp(),
        resetLock: null,
        updatedAt: serverTimestamp()
      });
      return;
    }

    const newMatches = buildMatches(winners);
    const nextCandidates = [];
    for (const m of newMatches){
      if (m.left && !m.right){ m.winner = m.left; nextCandidates.push(m.left); }
      else if (!m.left && m.right){ m.winner = m.right; nextCandidates.push(m.right); }
    }
    const newIndex = firstPlayableIndex(newMatches);

    tx.update(ref, {
      round: (d.round ?? 1) + 1,
      matchIndex: newIndex,
      matches: newMatches,
      nextCandidates,
      updatedAt: serverTimestamp()
    });
  });
}

/* ===== 投票 ===== */
/* ✅ 変更：setTimeout(startNextRound) を削除し、次インデックスは bye/決着済みをスキップ */
async function vote(side){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(ref);
    if (!snap.exists()) throw "not-found";
    const d = snap.data();
    if (d.champion) return;

    const idx = d.matchIndex ?? 0;
    const matches = d.matches ?? [];
    const m = matches[idx];
    if (!m || m.winner) return;
    if (!m.left || !m.right) return;

    if (side === 'left') m.leftCount = (m.leftCount ?? 0) + 1;
    else m.rightCount = (m.rightCount ?? 0) + 1;

    const threshold = d.threshold ?? VOTE_THRESHOLD;
    if ((m.leftCount ?? 0) >= threshold || (m.rightCount ?? 0) >= threshold){
      m.winner = (m.leftCount >= m.rightCount) ? m.left : m.right;
      const next = (d.nextCandidates ?? []).slice();
      next.push(m.winner);

      let nextIndex = (d.matchIndex ?? 0) + 1;
      while (nextIndex < matches.length) {
        const nm = matches[nextIndex];
        if (nm.left && nm.right && !nm.winner) break;
        nextIndex++;
      }

      tx.update(ref, { matches, nextCandidates: next, matchIndex: nextIndex, updatedAt: serverTimestamp() });
    } else {
      tx.update(ref, { matches, updatedAt: serverTimestamp() });
    }
  });
}

/* ===== UI制御 ===== */
const $ = (id)=>document.getElementById(id);
$("btn-left").addEventListener("click", () => vote('left'));
$("btn-right").addEventListener("click", () => vote('right'));

/* ===== 自動再初期化（新しい128を毎回抽選） ===== */
async function reinitTournament(){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  const allShuffled = shuffle(OPTIONS);
  const selected128 = allShuffled.slice(0, 128);
  const matches = buildMatches(selected128);
  const nextCandidates = [];
  for (const m of matches){
    if (m.left && !m.right){ m.winner = m.left; nextCandidates.push(m.left); }
    else if (!m.left && m.right){ m.winner = m.right; nextCandidates.push(m.right); }
  }
  /* ✅ ここでも playableIndex を設定 */
  const matchIndex = firstPlayableIndex(matches);

  await setDoc(ref, {
    round: 1, matchIndex, matches, nextCandidates,
    champion: null, threshold: VOTE_THRESHOLD,
    updatedAt: serverTimestamp(),
    totalCandidates: 128,
    views: 0,
    /* ✅ リセット後はロックを解放 */
    resetLock: null,
    championAt: null
  });
}

/* ===== 閲覧数加算（優勝が決まるまで1ビュー＝+1） ===== */
/* ✅ 修正：onlyIfZero=true のときは views===0 の場合のみ原子的に +1（新トーナメント開始時の過剰加算を防止） */
async function bumpView(onlyIfZero = false){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  try {
    await runTransaction(db, async (tx) => {
      const snap = await tx.get(ref);
      if (!snap.exists()) return;
      const d = snap.data();
      if (d.champion) return; // 優勝後は加算しない
      const current = d.views ?? 0;

      if (onlyIfZero && current > 0) {
        return; // 新トーナメント自動加算は 0→1 のときだけ
      }

      tx.update(ref, { views: current + 1, updatedAt: serverTimestamp() });
    });
  } catch (e) {
    console.error("bumpView failed:", e);
  }
}

/* ===== 新トーナメント検出で自動ビュー加算 ===== */
let lastTournamentMarker = null;

/* ===== チャンピオン後のリセット：排他ロック取得＆遅延実行 ===== */
let resetTimerStarted = false;
async function acquireResetLockAndSchedule(d){
  if (resetTimerStarted) return;
  resetTimerStarted = true;

  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  let iHoldTheLock = false;

  await runTransaction(db, async (tx) => {
    const snap = await tx.get(ref);
    if (!snap.exists()) return;
    const cur = snap.data();

    // すでにロックがあり、他人のロックなら何もしない
    if (cur.resetLock && cur.resetLock.by && cur.resetLock.by !== CLIENT_ID) {
      return;
    }
    // ロックが無ければ自分が取得
    if (!cur.resetLock) {
      tx.update(ref, { resetLock: { by: CLIENT_ID, at: serverTimestamp() } });
      iHoldTheLock = true;
      return;
    }
    // 自分のロックなら保持
    if (cur.resetLock && cur.resetLock.by === CLIENT_ID) {
      iHoldTheLock = true;
    }
  });

  // 自分がロックを持っていないなら終了（他クライアントが担当）
  if (!iHoldTheLock) {
    resetTimerStarted = false;
    return;
  }

  // 数秒待ってから再チェックし、ロック保持者のみ再初期化を実行
  setTimeout(async () => {
    const snap = await getDoc(ref);
    const after = snap.data?.();
    if (after && after.resetLock && after.resetLock.by === CLIENT_ID && after.champion) {
      await reinitTournament();
    }
    resetTimerStarted = false;
  }, 3000); // 表示時間（ms）
}

/* ===== 状態監視 ===== */
onSnapshot(doc(db, "tournaments", TOURNAMENT_DOC_ID), (snap) => {
  const d = snap.data();
  if (!d) return;

  // 新トーナメント識別：先頭数試合の組合せをマーカー化
  const marker = JSON.stringify((d.matches ?? []).slice(0, 6).map(m => [m.left, m.right]));
  if (marker && marker !== lastTournamentMarker) {
    // Round10終了→再抽選直後は round=1 & views=0 のはず → その場の閲覧者を+1（0→1 の時だけ原子的に加算）
    if ((d.round ?? 1) === 1 && (d.views ?? 0) === 0) {
      bumpView(true); // ✅ ここは「views が 0 の時だけ」加算
    }
    lastTournamentMarker = marker; // 二重加算防止（クライアント内）
  }

  // 表示ラウンド（内部+2、最大10）
  const displayedRound = calcDisplayedRound(d.round);
  $("round-label").textContent = `Round: ${displayedRound}`;

  // 閲覧数表示
  $("view-label").textContent = `Views: ${d.views ?? 0}`;

  // ✅ チャンピオン確定時：UIはそのまま、リセットは排他ロックで1クライアントのみ担当
  if (d.champion){
    $("round-label").textContent = "Round: 10";
    acquireResetLockAndSchedule(d);
    return;
  }

  // ✅ ラウンドが全試合終了したら次ラウンドへ（単発：関数内でトランザクション判定）
  if (!d.champion && Array.isArray(d.matches) && d.matches.length > 0 && allResolved(d.matches)){
    startNextRound();
    return;
  }

  const idx = d.matchIndex ?? 0;
  const match = d.matches?.[idx];

  if (!match){
    return;
  }

  $("label-left").textContent  = match.left  ?? "—";
  $("label-right").textContent = match.right ?? "—";

  const playable = !!(match.left && match.right && !match.winner);
  $("btn-left").disabled  = !playable;
  $("btn-right").disabled = !playable;
});

/* ===== 起動：初回表示の閲覧をカウント ===== */
initTournamentIfNeeded().then(() => bumpView());
</script>
</body>
</html>

