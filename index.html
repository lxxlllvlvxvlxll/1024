<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>headtohead</title>

  <!-- ✅ 外部CSSを読み込む -->
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="qwrap">
    <p class="round-label" id="round-label">Round: —</p>
    <p class="view-label"  id="view-label">Views: 0</p>
    <p class="question" aria-live="polite">
      <button class="name-btn" id="btn-left" title="左に投票">
        <strong id="label-left">—</strong>
      </button>
      か
      <button class="name-btn" id="btn-right" title="右に投票">
        <strong id="label-right">—</strong>
      </button>
    </p>
  </div>

<script type="module">
/* ===== Firebase v12.4.0（変更不可） ===== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc,
  runTransaction, onSnapshot, serverTimestamp
} from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCRHvaE9WMODFhDau9sgqs11lzkW6wrFbc",
  authDomain: "project-617841149941118768.firebaseapp.com",
  projectId: "project-617841149941118768",
  storageBucket: "project-617841149941118768.firebasestorage.app",
  messagingSenderId: "699664731293",
  appId: "1:699664731293:web:0ab38c64fb6fc023049874"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ===== 候補一覧（1024件想定：実装では全件を配置） ===== */
const OPTIONS = [
"りんご","オレンジ","ぶどう","もも","スイカ","バナナ","パイナップル","いちご","マンゴー","メロン",
"キウイ","さくらんぼ","レモン","ライム","ブルーベリー","ラズベリー","ブラックベリー","プラム","あんず","ココナッツ",
"パパイヤ","いちじく","デーツ","グアバ","ライチ","パッションフルーツ","ザクロ","クランベリー","みかん","かき",
"マルベリー","トマト","アボカド","オリーブ","きゅうり","かぼちゃ","にんじん","じゃがいも","たまねぎ","にんにく",
"ブロッコリー","カリフラワー","ほうれんそう","レタス","キャベツ","セロリ","えんどう","まめ","とうもろこし","こめ",
"むぎ","オート麦","大麦","ライ麦","きび","もろこし","キヌア","アマランサス","そば","アーモンド",
"くるみ","ピーカンナッツ","ヘーゼルナッツ","カシューナッツ","ピスタチオ","マカダミアナッツ","くり","ピーナッツ","ひまわり","ごま",
"チア","ココナッツウォーター","はちみつ","砂糖","塩","こしょう","酢","油","バター","チーズ",
"牛乳","クリーム","ヨーグルト","卵","パン","ケーキ","パイ","クッキー","チョコレート","キャンディ",
"コーヒー","お茶","ジュース","水","ソーダ","ビール","ワイン","ウイスキー","ラム","ウォッカ",
"ジン","ブランデー","シャンパン","シードル","スムージー","スープ","シチュー","サラダ","パスタ","ピザ",
"バーガー","サンドイッチ","すし","カレー","ステーキ","チキン","ビーフ","ポーク","魚","えび",
"かに","ロブスター","たこ","いか","豆腐","めん","ぎょうざ","おにぎり","弁当","てんぷら",
"ラーメン","うどん","そば","シリアル","おかゆ","オムレツ","トースト","ジャム","バタートースト","チーズトースト",
"ポップコーン","ナチョス","タコス","ブリトー","ケサディーヤ","ホットドッグ","フライドポテト","ケチャップ","マスタード","マヨネーズ",
"カップラーメン","インスタント麺","もち","プリン","アイスクリーム","ジェラート","ソルベ","ドーナツ","パンケーキ","ワッフル",
"マフィン","クロワッサン","ベーグル","プレッツェル","ビスケット","グラノーラ","トレイルミックス","ソーセージ","ハム","ベーコン",
"サラミ","プロシュート","キャビア","さしみ","天ぷらえび","焼き魚","てりやき","やきとり","そばめん","すきやき",
"しゃぶしゃぶ","なべ","キムチ","ビビンバ","トッポギ","キンパ","フォー","春巻き","水餃子","チャーハン",
"キャセロール","リゾット","パエリア","ラザニア","スパゲッティ","カルボナーラ","ボロネーゼ","ティラミス","ゼリー","カスタード",
"トリュフ","魚卵","わさび","しょうゆ","みそ","海藻","のり","ごま油","日本酒","焼酎"
];

/* ===== パラメータ ===== */
const TOURNAMENT_DOC_ID = "main";
const VOTE_THRESHOLD    = 1;

/* ===== 表示補正（Round表示は内部+2、最大10） ===== */
const DISPLAY_OFFSET = 2;
const calcDisplayedRound = (internalRound) =>
  Math.min((internalRound ?? 1) + DISPLAY_OFFSET, 10);

/* ===== ユーティリティ ===== */
function shuffle(arr){
  const a = arr.slice();
  for (let i=a.length-1; i>0; i--){
    const j = crypto.getRandomValues(new Uint32Array(1))[0] % (i+1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function buildMatches(participants){
  const p = shuffle(participants);
  const m = [];
  let id = 1;
  for (let i=0; i<p.length; i+=2){
    m.push({ id:id++, left:p[i] ?? null, right:p[i+1] ?? null, winner:null, leftCount:0, rightCount:0 });
  }
  return m;
}
function allResolved(matches){ return matches.every(x => x.winner !== null); }

/* ===== 初期化（毎回1024→128候補ランダム抽出） ===== */
async function initTournamentIfNeeded(){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  const snap = await getDoc(ref);
  if (snap.exists()) return;

  // 1024候補からランダムに128個抽出
  const allShuffled = shuffle(OPTIONS);
  const selected128 = allShuffled.slice(0, 128);

  // 内部ラウンド1で開始（表示は+2補正でRound 3）
  const matches = buildMatches(selected128);
  const nextCandidates = [];
  for (const m of matches){
    if (m.left && !m.right){ m.winner = m.left; nextCandidates.push(m.left); }
    else if (!m.left && m.right){ m.winner = m.right; nextCandidates.push(m.right); }
  }

  await setDoc(ref, {
    round: 1,
    matchIndex: 0,
    matches,
    nextCandidates,
    champion: null,
    threshold: VOTE_THRESHOLD,
    updatedAt: serverTimestamp(),
    totalCandidates: 128,
    views: 0
  });
}

/* ===== ラウンド遷移 ===== */
async function startNextRound(docData){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  const winners = (docData.nextCandidates ?? []).slice();
  if (winners.length === 0) return;
  if (winners.length === 1){
    await updateDoc(ref, { champion: winners[0], updatedAt: serverTimestamp() });
    return;
  }
  const matches = buildMatches(winners);
  const nextCandidates = [];
  for (const m of matches){
    if (m.left && !m.right){ m.winner = m.left; nextCandidates.push(m.left); }
    else if (!m.left && m.right){ m.winner = m.right; nextCandidates.push(m.right); }
  }
  await updateDoc(ref, {
    round: (docData.round ?? 1) + 1,
    matchIndex: 0,
    matches,
    nextCandidates,
    updatedAt: serverTimestamp()
  });
}

/* ===== 投票 ===== */
async function vote(side){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(ref);
    if (!snap.exists()) throw "not-found";
    const d = snap.data();
    if (d.champion) return;

    const idx = d.matchIndex ?? 0;
    const matches = d.matches ?? [];
    const m = matches[idx];
    if (!m || m.winner) return;
    if (!m.left || !m.right) return;

    if (side === 'left') m.leftCount = (m.leftCount ?? 0) + 1;
    else m.rightCount = (m.rightCount ?? 0) + 1;

    const threshold = d.threshold ?? VOTE_THRESHOLD;
    if ((m.leftCount ?? 0) >= threshold || (m.rightCount ?? 0) >= threshold){
      m.winner = (m.leftCount >= m.rightCount) ? m.left : m.right;
      const next = (d.nextCandidates ?? []).slice();
      next.push(m.winner);

      let matchIndex = (d.matchIndex ?? 0) + 1;
      while (matchIndex < matches.length && matches[matchIndex].winner) matchIndex++;

      tx.update(ref, { matches, nextCandidates: next, matchIndex, updatedAt: serverTimestamp() });

      setTimeout(async () => {
        const after = (await getDoc(ref)).data();
        if (after && allResolved(after.matches)) await startNextRound(after);
      }, 0);
    } else {
      tx.update(ref, { matches, updatedAt: serverTimestamp() });
    }
  });
}

/* ===== UI制御 ===== */
const $ = (id)=>document.getElementById(id);
$("btn-left").addEventListener("click", () => vote('left'));
$("btn-right").addEventListener("click", () => vote('right'));

/* ===== 自動再初期化（新しい128を毎回抽選） ===== */
async function reinitTournament(){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  const allShuffled = shuffle(OPTIONS);
  const selected128 = allShuffled.slice(0, 128);
  const matches = buildMatches(selected128);
  const nextCandidates = [];
  for (const m of matches){
    if (m.left && !m.right){ m.winner = m.left; nextCandidates.push(m.left); }
    else if (!m.left && m.right){ m.winner = m.right; nextCandidates.push(m.right); }
  }
  await setDoc(ref, {
    round: 1, matchIndex: 0, matches, nextCandidates,
    champion: null, threshold: VOTE_THRESHOLD,
    updatedAt: serverTimestamp(),
    totalCandidates: 128,
    views: 0
  });
}

/* ===== 閲覧数加算（優勝が決まるまで1ビュー＝+1） ===== */
async function bumpView(){
  const ref = doc(db, "tournaments", TOURNAMENT_DOC_ID);
  try {
    await runTransaction(db, async (tx) => {
      const snap = await tx.get(ref);
      if (!snap.exists()) return;
      const d = snap.data();
      if (d.champion) return; // 優勝後は加算しない
      const current = d.views ?? 0;
      tx.update(ref, { views: current + 1, updatedAt: serverTimestamp() });
    });
  } catch (e) {
    console.error("bumpView failed:", e);
  }
}

/* ===== 状態監視 ===== */
let resetting = false;
let advancingRound = false;

onSnapshot(doc(db, "tournaments", TOURNAMENT_DOC_ID), (snap) => {
  const d = snap.data();
  if (!d) return;

  // 表示ラウンドは内部+2（最大10）
  const displayedRound = calcDisplayedRound(d.round);
  $("round-label").textContent = `Round: ${displayedRound}`;

  // 閲覧数表示
  $("view-label").textContent = `Views: ${d.views ?? 0}`;

  // 優勝が決まったら、まず Round 10 を表示してから再初期化
  if (d.champion && !resetting){
    $("round-label").textContent = "Round: 10";
    resetting = true;
    reinitTournament().finally(()=>{ resetting = false; });
    return;
  }

  // ラウンドが全試合終了したら次ラウンド
  if (!d.champion && Array.isArray(d.matches) && d.matches.length > 0 && allResolved(d.matches) && !advancingRound){
    advancingRound = true;
    startNextRound(d).finally(()=>{ advancingRound = false; });
    return;
  }

  const idx = d.matchIndex ?? 0;
  const match = d.matches?.[idx];

  if (!match){
    if (!d.champion && Array.isArray(d.matches) && (allResolved(d.matches) || idx >= d.matches.length) && !advancingRound){
      advancingRound = true;
      startNextRound(d).finally(()=>{ advancingRound = false; });
    }
    return;
  }

  $("label-left").textContent  = match.left  ?? "—";
  $("label-right").textContent = match.right ?? "—";

  const playable = !!(match.left && match.right && !match.winner);
  $("btn-left").disabled  = !playable;
  $("btn-right").disabled = !playable;
});

/* ===== 起動 ===== */
initTournamentIfNeeded().then(() => bumpView());
</script>
</body>
</html>
